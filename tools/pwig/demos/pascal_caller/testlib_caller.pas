// ************************************************************************
// This file implements library imports for the caller.
// -------
// WARNING
// -------
// This file was generated by PWIG. Do not edit.
// File generated on 4.1.2017 17:40:15

unit testlib_caller;

{$IFDEF FPC}{$MODE DELPHI}{$ENDIF}

// Library properties:
// Name: TestLib
// Version: 1.0
// GUID: F3C093C0-035B-4C33-BB28-C1FDE270D3B5
// Description: Test library

interface

uses
  {$IFDEF FPC}
  DynLibs,
  {$ELSE}
  {$IFDEF MSWINDOWS}
  Windows,
  {$ENDIF}
  {$ENDIF}
  testlib_intf;

type

  // Forward declarations:
  TProjectGroup = class;
  TProject = class;

  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  TProjectGroupIProjectGroupEventsOnErrorEvent = procedure(const ErrorCode: TErrorCode; const ErrorText: string) of object;
  TProjectGroupIProjectGroupEventsOnProgressEvent = procedure(const EventCode: TProgressEvent; const ProgressValue: LongInt; const EventText: string) of object;

  TProjectGroup = class(TObject)
  private
    FOnError: TProjectGroupIProjectGroupEventsOnErrorEvent;
    FOnProgress: TProjectGroupIProjectGroupEventsOnProgressEvent;
    FItemHandle: IProjectGroup;
    // Property getters and setters:
  public
    constructor Create(AInterfaceHandle: IProjectGroup = 0);
    destructor Destroy; override;
    // Methods:
    function AddProject: IProject;
    procedure RunPeriodic;
    procedure Finalize;
    // Properties:
    // Events:
    property OnError: TProjectGroupIProjectGroupEventsOnErrorEvent read FOnError write FOnError;
    property OnProgress: TProjectGroupIProjectGroupEventsOnProgressEvent read FOnProgress write FOnProgress;
    // Default interface handle:
    property Handle: IProjectGroup read FItemHandle;
  end;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object


  TProject = class(TObject)
  private
    FItemHandle: IProject;
    // Property getters and setters:
    function GetConnectionFRC: LongInt;
    function GetConnectionString: string;
  public
    constructor Create(AInterfaceHandle: IProject = 0);
    destructor Destroy; override;
    // Methods:
    procedure Connect;
    procedure Disconnect;
    function LoadFromFile(const Path: string): TBool;
    function SaveToFile(const Path: string): TBool;
    // Properties:
    property ConnectionFRC: LongInt read GetConnectionFRC;
    property ConnectionString: string read GetConnectionString;
    // Default interface handle:
    property Handle: IProject read FItemHandle;
  end;

  function TestLibLibLoad(const FileName: string): Boolean;
  procedure TestLibLibUnload;
  var LibLoadErrorMsg: string;
implementation

uses
  Math, SysUtils;

const
  LibModule: HMODULE = 0;
  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  // Constructor:
  FuncProjectGroupCreate: TProjectGroupCreate = nil;
  // Destructor:
  FuncProjectGroupDestroy: TProjectGroupDestroy = nil;
  // Methods:
  FuncProjectGroupIProjectGroupAddProject: TIProjectGroupAddProject = nil;
  FuncProjectGroupIProjectGroupRunPeriodic: TIProjectGroupRunPeriodic = nil;
  FuncProjectGroupIProjectGroupFinalize: TIProjectGroupFinalize = nil;
  // Properties:
  // Event handler setters:
  FuncSetProjectGroupIProjectGroupEventsOnError: TSetProjectGroupIProjectGroupEventsOnError = nil;
  FuncSetProjectGroupIProjectGroupEventsOnProgress: TSetProjectGroupIProjectGroupEventsOnProgress = nil;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object

  // Constructor:
  FuncProjectCreate: TProjectCreate = nil;
  // Destructor:
  FuncProjectDestroy: TProjectDestroy = nil;
  // Methods:
  FuncProjectIProjectConnect: TIProjectConnect = nil;
  FuncProjectIProjectDisconnect: TIProjectDisconnect = nil;
  FuncProjectIProjectLoadFromFile: TIProjectLoadFromFile = nil;
  FuncProjectIProjectSaveToFile: TIProjectSaveToFile = nil;
  // Properties:
  FuncProjectGetIProjectConnectionFRC: TGetIProjectConnectionFRC = nil;
  FuncProjectGetIProjectConnectionString: TGetIProjectConnectionString = nil;

procedure LibError(const AMessage: string);
begin
  raise Exception.Create(AMessage);
end;

procedure LibCallError(const AFuncName: string);
begin
  LibError(Format('Error while calling library function %s!', [AFuncName]));
end;

procedure LibLoadError(const AFuncName: string);
begin
  LibError(Format('Requested function %s does not exist in the library!', [AFuncName]));
end;

function TestLibLibLoad(const FileName: string): Boolean;
type
  T_FuncLibID = function: PAnsichar; cdecl;
var
  _FuncLibID: T_FuncLibID;
begin
  Result := False;
  try
    if LibModule = 0 then
    begin
      LibModule := LoadLibrary({$IFnDEF FPC}PChar{$ENDIF}(FileName));
      {$IFDEF FPC}
      LibLoadErrorMsg := GetLoadErrorStr;
      {$ENDIF}
    end;
    if LibModule <> 0 then
    begin
      // Call library identification code first
      _FuncLibID := GetProcAddress(LibModule, 'GetLibGUID');
      if not Assigned(_FuncLibID) then LibLoadError('GetLibGUID');
      if _FuncLibID <> cLibGUID then LibError('Incompatible library interface!');

      // Name: ProjectGroup
      // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
      // Description: ProjectGroup Object

      // Constructor:
      FuncProjectGroupCreate := GetProcAddress(LibModule, 'ProjectGroupCreate');
      if not Assigned(FuncProjectGroupCreate) then LibLoadError('ProjectGroupCreate');
      // Destructor:
      FuncProjectGroupDestroy := GetProcAddress(LibModule, 'ProjectGroupDestroy');
      if not Assigned(FuncProjectGroupDestroy) then LibLoadError('ProjectGroupDestroy');
      // Methods:
      FuncProjectGroupIProjectGroupAddProject := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupAddProject');
      if not Assigned(FuncProjectGroupIProjectGroupAddProject) then LibLoadError('ProjectGroupIProjectGroupAddProject');
      FuncProjectGroupIProjectGroupRunPeriodic := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupRunPeriodic');
      if not Assigned(FuncProjectGroupIProjectGroupRunPeriodic) then LibLoadError('ProjectGroupIProjectGroupRunPeriodic');
      FuncProjectGroupIProjectGroupFinalize := GetProcAddress(LibModule, 'ProjectGroupIProjectGroupFinalize');
      if not Assigned(FuncProjectGroupIProjectGroupFinalize) then LibLoadError('ProjectGroupIProjectGroupFinalize');
      // Properties:
      // Event handler setters:
      FuncSetProjectGroupIProjectGroupEventsOnError := GetProcAddress(LibModule, 'SetProjectGroupIProjectGroupEventsOnError');
      if not Assigned(FuncSetProjectGroupIProjectGroupEventsOnError) then LibLoadError('SetProjectGroupIProjectGroupEventsOnError');
      FuncSetProjectGroupIProjectGroupEventsOnProgress := GetProcAddress(LibModule, 'SetProjectGroupIProjectGroupEventsOnProgress');
      if not Assigned(FuncSetProjectGroupIProjectGroupEventsOnProgress) then LibLoadError('SetProjectGroupIProjectGroupEventsOnProgress');
      // Name: Project
      // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
      // Description: Project Object

      // Constructor:
      FuncProjectCreate := GetProcAddress(LibModule, 'ProjectCreate');
      if not Assigned(FuncProjectCreate) then LibLoadError('ProjectCreate');
      // Destructor:
      FuncProjectDestroy := GetProcAddress(LibModule, 'ProjectDestroy');
      if not Assigned(FuncProjectDestroy) then LibLoadError('ProjectDestroy');
      // Methods:
      FuncProjectIProjectConnect := GetProcAddress(LibModule, 'ProjectIProjectConnect');
      if not Assigned(FuncProjectIProjectConnect) then LibLoadError('ProjectIProjectConnect');
      FuncProjectIProjectDisconnect := GetProcAddress(LibModule, 'ProjectIProjectDisconnect');
      if not Assigned(FuncProjectIProjectDisconnect) then LibLoadError('ProjectIProjectDisconnect');
      FuncProjectIProjectLoadFromFile := GetProcAddress(LibModule, 'ProjectIProjectLoadFromFile');
      if not Assigned(FuncProjectIProjectLoadFromFile) then LibLoadError('ProjectIProjectLoadFromFile');
      FuncProjectIProjectSaveToFile := GetProcAddress(LibModule, 'ProjectIProjectSaveToFile');
      if not Assigned(FuncProjectIProjectSaveToFile) then LibLoadError('ProjectIProjectSaveToFile');
      // Properties:
      FuncProjectGetIProjectConnectionFRC := GetProcAddress(LibModule, 'ProjectGetIProjectConnectionFRC');
      if not Assigned(FuncProjectGetIProjectConnectionFRC) then LibLoadError('ProjectGetIProjectConnectionFRC');
      FuncProjectGetIProjectConnectionString := GetProcAddress(LibModule, 'ProjectGetIProjectConnectionString');
      if not Assigned(FuncProjectGetIProjectConnectionString) then LibLoadError('ProjectGetIProjectConnectionString');
      Result := True;
    end;
  except
  end;
end;

procedure TestLibLibUnload;
begin
  if LibModule <> 0 then
    FreeLibrary(LibModule);
  LibModule := 0;
  // Name: ProjectGroup
  // GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
  // Description: ProjectGroup Object

  // Constructor:
  FuncProjectGroupCreate := nil;
  // Destructor:
  FuncProjectGroupDestroy := nil;
  // Methods:
  FuncProjectGroupIProjectGroupAddProject := nil;
  FuncProjectGroupIProjectGroupRunPeriodic := nil;
  FuncProjectGroupIProjectGroupFinalize := nil;
  // Properties:
  // Event handler setters:
  FuncSetProjectGroupIProjectGroupEventsOnError := nil;
  FuncSetProjectGroupIProjectGroupEventsOnProgress := nil;

  // Name: Project
  // GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
  // Description: Project Object

  // Constructor:
  FuncProjectCreate := nil;
  // Destructor:
  FuncProjectDestroy := nil;
  // Methods:
  FuncProjectIProjectConnect := nil;
  FuncProjectIProjectDisconnect := nil;
  FuncProjectIProjectLoadFromFile := nil;
  FuncProjectIProjectSaveToFile := nil;
  // Properties:
  FuncProjectGetIProjectConnectionFRC := nil;
  FuncProjectGetIProjectConnectionString := nil;

end;

// Name: ProjectGroup
// GUID: 7C12BB43-A6AB-4A52-8B1D-EDD5D94B344B
// Description: ProjectGroup Object

// Event handler callbacks:

function ProjectGroupIProjectGroupEventsOnError(const ItemHandle: IProjectGroupEvents; const ErrorCode: TErrorCode; const ErrorText: PAnsiChar): Boolean; cdecl;
begin
  Result := False;
  try
    if TObject(ItemHandle) is TProjectGroup then
    begin
      if Assigned(TProjectGroup(ItemHandle).OnError) then
      begin
        TProjectGroup(ItemHandle).OnError(ErrorCode, LibUtf8String2String(ErrorText));
      end;
      Result := True;
    end;
  except
  end;
end;


function ProjectGroupIProjectGroupEventsOnProgress(const ItemHandle: IProjectGroupEvents; const EventCode: TProgressEvent; const ProgressValue: LongInt; const EventText: PAnsiChar): Boolean; cdecl;
begin
  Result := False;
  try
    if TObject(ItemHandle) is TProjectGroup then
    begin
      if Assigned(TProjectGroup(ItemHandle).OnProgress) then
      begin
        TProjectGroup(ItemHandle).OnProgress(EventCode, ProgressValue, LibUtf8String2String(EventText));
      end;
      Result := True;
    end;
  except
  end;
end;

// Constructor:
constructor TProjectGroup.Create(AInterfaceHandle: IProjectGroup);
begin
  try
    FItemHandle := AInterfaceHandle;
    if (FItemHandle = 0) and Assigned(FuncProjectGroupCreate) then
      FuncProjectGroupCreate(FItemHandle);
    FOnError := nil;
    if Assigned(FuncSetProjectGroupIProjectGroupEventsOnError) then
    begin
      if not (
        FuncSetProjectGroupIProjectGroupEventsOnError(FItemHandle, IProjectGroupEvents(Self), ProjectGroupIProjectGroupEventsOnError)
      ) then LibError('FuncSetProjectGroupIProjectGroupEventsOnError');
    end;
    FOnProgress := nil;
    if Assigned(FuncSetProjectGroupIProjectGroupEventsOnProgress) then
    begin
      if not (
        FuncSetProjectGroupIProjectGroupEventsOnProgress(FItemHandle, IProjectGroupEvents(Self), ProjectGroupIProjectGroupEventsOnProgress)
      ) then LibError('FuncSetProjectGroupIProjectGroupEventsOnProgress');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Destructor:
destructor TProjectGroup.Destroy;
begin
  try
    if Assigned(FuncProjectGroupDestroy) then
      FuncProjectGroupDestroy(FItemHandle);
    inherited;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Methods:
function TProjectGroup.AddProject: IProject;
begin
  try
    if Assigned(FuncProjectGroupIProjectGroupAddProject) then
    begin
      if not (
        FuncProjectGroupIProjectGroupAddProject(FItemHandle, Result)
      ) then LibError('FuncProjectGroupIProjectGroupAddProject');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

procedure TProjectGroup.RunPeriodic;
begin
  try
    if Assigned(FuncProjectGroupIProjectGroupRunPeriodic) then
    begin
      if not (
        FuncProjectGroupIProjectGroupRunPeriodic(FItemHandle)
      ) then LibError('FuncProjectGroupIProjectGroupRunPeriodic');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

procedure TProjectGroup.Finalize;
begin
  try
    if Assigned(FuncProjectGroupIProjectGroupFinalize) then
    begin
      if not (
        FuncProjectGroupIProjectGroupFinalize(FItemHandle)
      ) then LibError('FuncProjectGroupIProjectGroupFinalize');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Properties:

// Name: Project
// GUID: D96EA22B-D750-4C05-9F32-8C5C8E9F846D
// Description: Project Object

// Constructor:
constructor TProject.Create(AInterfaceHandle: IProject);
begin
  try
    FItemHandle := AInterfaceHandle;
    if (FItemHandle = 0) and Assigned(FuncProjectCreate) then
      FuncProjectCreate(FItemHandle);
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Destructor:
destructor TProject.Destroy;
begin
  try
    if Assigned(FuncProjectDestroy) then
      FuncProjectDestroy(FItemHandle);
    inherited;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Methods:
procedure TProject.Connect;
begin
  try
    if Assigned(FuncProjectIProjectConnect) then
    begin
      if not (
        FuncProjectIProjectConnect(FItemHandle)
      ) then LibError('FuncProjectIProjectConnect');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

procedure TProject.Disconnect;
begin
  try
    if Assigned(FuncProjectIProjectDisconnect) then
    begin
      if not (
        FuncProjectIProjectDisconnect(FItemHandle)
      ) then LibError('FuncProjectIProjectDisconnect');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

function TProject.LoadFromFile(const Path: string): TBool;
begin
  try
    if Assigned(FuncProjectIProjectLoadFromFile) then
    begin
      if not (
        FuncProjectIProjectLoadFromFile(FItemHandle, PAnsiChar(String2LibUtf8String(Path)), Result)
      ) then LibError('FuncProjectIProjectLoadFromFile');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

function TProject.SaveToFile(const Path: string): TBool;
begin
  try
    if Assigned(FuncProjectIProjectSaveToFile) then
    begin
      if not (
        FuncProjectIProjectSaveToFile(FItemHandle, PAnsiChar(String2LibUtf8String(Path)), Result)
      ) then LibError('FuncProjectIProjectSaveToFile');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

// Properties:
function TProject.GetConnectionFRC: LongInt;
begin
  try
    if Assigned(FuncProjectGetIProjectConnectionFRC) then
    begin
      if not (
        FuncProjectGetIProjectConnectionFRC(FItemHandle, Result)
      ) then LibError('FuncProjectGetIProjectConnectionFRC');
    end;
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;

function TProject.GetConnectionString: string;
var
  AnsiString__Value: AnsiString; Length__Value: LongInt;
begin
  try
    if Assigned(FuncProjectGetIProjectConnectionString) then
    begin
      Length__Value := 0;
      if not (
        FuncProjectGetIProjectConnectionString(FItemHandle, nil, Length__Value)
      ) then LibError('FuncProjectGetIProjectConnectionString');
      SetLength(AnsiString__Value, Max(Length__Value, 1));
      if not (
        FuncProjectGetIProjectConnectionString(FItemHandle, PAnsiChar(AnsiString__Value), Length__Value)
      ) then LibError('FuncProjectGetIProjectConnectionString');
    end;
    if Length__Value > 0 then Result := LibUtf8String2String(AnsiString__Value) else Result := '';
  except
    on E : Exception do LibCallError(E.Message);
  end;
end;


end.
